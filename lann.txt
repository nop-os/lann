NOTE: This guide, although complete and official, is written with an
excessively informal tone, and tries to make it as entretaining as a
language's official documentation could be.

---

Welcome, traveller, to the amazing world of the lann programming
language. In this document, we'll explore thoroughly every single
detail about this language.

1. Programming in lann

So, you finally decided to start with us this incredible adventure. To
do so, we'll open the lann REPL by running the provided executable
with no arguments. After proceding to do so, you should get a prompt
like this:

lann rXX, by segfaultdev
> 

If so, congratulations, you just did the hardest part of it all
already! Let's now make lann salute us by typing:

> put_text("Hello, traveller!")

After typing that and pressing Enter, you'll be surprised with the
same salute we wrote there:

Hello, traveller!> 

Trying to decompose that magical statement, we can find several
different parts:

put_text

That's the function we are trying to call, and it's called (haha
funny) "put_text". A function is kinda like a spell, it's made of one
or more smaller steps and it produces a final result like, in this
case, get greeted by the interpreter (or print any piece of text,
usually called "string" in programming). lann has several predefined
functions, like the one we used, that will help us write our amazing
programs during our adventure! Let's continue:

(

So, really briefly, this tells lann that we are calling put_text, and
treats everything after that, until a matching closing parenthesis, as
a parameter to customize what our function does (in this case, it
specifies what string to show to the screen). This parameter thingie
is usually called an "argument" to the function. Neeeext:

"Hello, traveller!"

Ohohohoh, we're getting to the kewl stuff! So this is one of those
"strings", and ironically, they're always written in between quotation
marks like I did with the word "strings"! Fuck, did it again. Now,
this is our first (and only in this case) parameter to the "put_text"
function, so this is what the function will take and show on the
wonderful screen. And finally:

)

That just tells lann to stop looking for more arguments, doesn't need
that much explanation. Let's get back to where we were:

> put_text("Hello, traveller!")
Hello, traveller!> 

But wait, why is the text in the same line as the prompt? Turns out,
this programming language I've been praising all along is too dumb to
separate text in a new line! And thus, we have to add a newline to the
string. However, if you felt quite the curious and already tried doing
this:

> put_text("Hello, traveller!
")

You'll then notice it didn't work. Moreover, you probably scared the
hell out of lann and made it hang forever (or not, depends on I fixed
infinite hangs for when you see this). If so, just hold Ctrl+C and
load lann again to continue with your adventure!

Let's get right into explaining how to do it properly then. To add
what we call "special" symbols to a string, just like a newline or a
quotation mark (yeah, you cant add double ones as it'll make lann 
think you are closing the string), you use backslash combinations,
like "\n" for newlines, "\"" for quotation marks, or "\\" to add a
single backslash to the text without making lann think you are making
a backslash conbination again. And if we try using that:

> put_text("Hello, traveller!\n")
Hello, traveller!
> 

Finally, it worked just like we wanted! But what if we wanna make it
more personal, like actually printing the name of the adventurer
instead? Well, lemme proceed to explaining to you, the traveller,
a new concept, "variables". These are magical slots with names where
you can save values, like the aforementioned strings or even numbers! Now we'll
try defining a new variable:

> let my_name: "seg"
= "seg"
>

As a note, that thing after the entered line (= "seg") is the result
of our expression (that's how we refer to all these line we've typed
so far). The reason we didn't see that with the "put_text" call is
because it didn't return any results, but this apparently does.
Anyway, we'll now proceed to inspect this expression in a piece-wise
manner, yet again:

let

New stuff, again! The "let" keyword (to the unknowing, a keyword is a
reserved word in a language used for special cases, and that can't be
used as a function or variable name) will let (see what I did there
xdxdxdx lolz) lann know you wanna define a new variable, and expects
some words following it:

my_name

This is the name your adventurous self chose to call the newly created
variable! Now, traveller, you should also know that variable and
function names (called identifiers to refer to them with a generic
word) can't be named however you want (you dummy), but instead follow
two rules: The first character must be a letter (case doesn't matter),
an underscore, a dollar sign or an at sign, and the following
characters can be any of the aforementioned, plus any numeric digit.
As you can see, spaces are not allowed, nor any Unicode character is.
Keep in mind that even though you can use letters of any case, lann is
case sensitive, so it will distinguish between those.

We'll skip the colon as that's actually just a piece of syntax sugar,
a symbol added just for code readability and that will be completely
ignored by lann (yes, that means you could fill your expressions
during this adventure with unnecessary colons if you really want...).

"seg"

And finally, we see a string yet again! This is the value the new
variable will be set to, and it can also be things like numbers or
even pointers (we'll see those later).

Returning back to the example, now that we defined the "my_name"
variable we can use it inside our example by typing its name inside
the call, and it will be replaced with its value:

> put_text("Hello, my_name!\n")
Hello, my_name!
> 

Wait, what happened? Why am I not seeing "Hello, seg!" there (or
whatever the traveller's name is)? The reason is, everything inside a
string will be treated as part of the string literally, so identifiers
and colons and such won't be interpreted by lann and will be shown to
the screen as-is. The solution to this is use a built-in feature of
lann called string formatting.

With string formatting, you can mark parts of an unformatted string
with symbols, "[]" in the case of lann, to later replace those with
a value of our choice, let it be a number or a string or anything! To
format an unformatted string, we use a built-in function called
"str_format":

> let unformatted_string: "[] + [] = []\n"
= "[] + [] = []\n"
> let formatted_string: str_format(unformatted_string, 3, 2, 5)
= "3 + 2 = 5\n"
>

Woah, that's a lot of code! Though don't worry, traveller, most of it
is actually due to an illusion caused by my excessively long variable
names. Let's inspect the code in a more crude manner than before, as
in theory you already understood the basics:

> let unformatted_string: "[] + [] = []\n"

There we are just defining the unformatted string to be formatted
later. Keep in mind that this is as valid of a string as any other,
those symbols are just literal symbols in the text, interpreted by
lann inside the "str_format" function. Next:

> let formatted_string: str_format(unformatted_string, 3, 2, 5)

Here, if we use our minuscule brains, we could notice that this is
just a variable definition where the value is the result of a
function, which coincidentally is the function we were talking about,
"str_format". It accepts any amount of arguments starting at 1, where
the first is our unformatted string to be interpreted by the function
and the rest just match one to one with each "[]" in the unformatted
string. As you might have guessed, the function is just creating a new
string where every mention of those symbols is replaced by the value
passed to it, which explains the result of the function being the
string "3 + 2 = 5\n". Now that we finished explaining it, we can try
printing our super duper personal salute with the "my_name" variable:

> let my_name: "seg"
= "seg"
> put_text(str_format("Hello, []!\n", my_name))
Hello, seg!
>

Don't be scared by the use of a function result as an argument to
another, it's quite similar to the "str_format" example but using the
values directly instead of defining a variable for each string used
or returned there. Now that we mastered string printing, lemme show
you a cool hackerz trick to make printing formatted strings directly
take less characters:

> printf("Hello, []!", my_name)
Hello, seg!
>

If you didn't notice, "printf" is a function identical to the
"str_format" one, but instead of returning the new formatted string,
it shows it on the screen. It can be incredibly useful for showing
text, and in most programs it's the only function used for that!

One thing you might have noticed is that we "hardcoded" (set in code,
without letting the user running the program change it dynamically)
the value of "my_name" to what we wanted, let it be "seg" of whatever
value you tried (yes, you are not only allowed for psicologically
forced to change stuff in the examples I show here!). What if the next
traveller isn't called like you or me? To fix that, we'll ask the user
what their name is, and then and only then show it in our even more
personalized salute, and to ask them we'll use a new built-in function
called "get_text":

let my_name: get_text()
printf("Hello, []\n", my_name)

Note that I didn't write the prompt (">") nor the intermediate results
("=") in that example. This is just the result of me getting lazy, as
you can still run this code by copying it line by line to the prompt
and running each expression with Enter. However, in order to make more
complex examples simpler to try out, I would recommend you writing all
your code inside files ending in ".ln" and then passing the path to
that file to the lann interpreter program. This will instantly run the
code, without showing any intermediate outputs or anything.

Anyway, after running that example, you'll get a message like
"Hello, [invalid type]!" directly and without asking you for the
traveller's name. The problem here is, that unlike "str_format", this
new function called "get_text" does not have the ability to return a
string. The reasoning behind this is complicated and will be clearer
in later parts of the guide, but for now know that we have to
"reserve" an empty slot to store the user's input. To do this, we'll
use yet another keyword, called "array". It's a really powerful
keyword, but for now it's going to be used just for reserving space
for strings:

array my_name: 101

Its syntax is very similar to that of "let": We write the keyword, we
specify a name and then, uhm, something. Unlike with "let", where that
something was the value to set the new variable to, here it's the
amount of space to reserve for the string. In this case, we are
reserving 101 places for characters to go in, but the last cannot be
used for complicated reasons, so we can store a string of up to 100
letters there. Let's try a full example now:

array my_name: 101
get_text(my_name)
printf("Hello, []!\n", my_name)

As you can see, "get_text" works by passing the space reserved for
that string, and then the function will automatically fill it with the
user input. Personally, I know these 5 paragraphs may sound way too
complicated for most people to understand but, please, don't give up
yet!

If you dare to try that example code, you'll be greeted with an empty
line, where it looks like the program is doing absolutely nothing.
This, however, isn't true at all, and instead lann is waiting for the
user to input a string (the name to show in this case) and then press
Enter to send it back to the program. Now, with this knowledge, if we
write in this lonely line the name of the traveller and press Enter,
we should see something like this:

Hello, Adolf!

Where "Adolf" is the name you entered. Funnily enough, this could be
any string, even empty ones or ones with spaces. Anyways, I think the
user may thank us if we added a prompt so they know when to start
introducing their super amazing name. Let's add that with something we
say back in the first code example, where we showed a generic salute
but without a newline. What I mean is that we can leave a line without
a jump to the next one at the end, and then expect the input after
that as if it were a prompt:

array my_name: 101

put_text("Name: ")
get_text(my_name)

printf("Hello, []!\n", my_name)

Another note: I've added some spaces between lines to make the code
cuter and cleaner, but they're not necessary, just so you know.

Finally, we've got a fully working and nice program, which should give
an output like this:

Name: Adolf
Hello, Adolf!

If so, congratulations, now you oficially made your first simple lann
program!

TODO: read numbers from user input, convert strings to numbers
TODO: see conditionals and code blocks (example of lambda)
TODO: see loops and changing variable values
TODO: see functions and scopes
TODO: see pointers and arrays
TODO: see error handling and type conversion

1.1. File handling

1.2. Terminal handling

2. External libraries

3. Embedding lann in other languages
